
## 1번 문제

### 해결방법 1

#### 순서
1. level에 따라 난이도의 범위와, 그 범위별로 할당된 비율을 구함
    - LOW인 경우 - 범위 별 할당 비율: 1..1 50%/2..4 30%/5..5 20%
    - MIDDLE인 경우 - 범위 별 할당 비율: 1..1 25%/2..4 50%/5..5 25%
    - HIGH인 경우 - 범위 별 할당 비율: 1..1 20%/2..4 30%/5..5 50%
2. totalCount와 비율을 곱하여 난이도의 범위별로 조회해야 할 갯수(할당된 수)를 구함
    - totalCount가 10이고, level이 LOW인 경우
      - 1..1: 10 * 0.5 = 5
      - 2..4: 10 * 0.3 = 3
      - 5..5: 10 * 0.2 = 2
3. 할당된 수 만큼 unitCodeList, problemType을 조건에 넣어 조회 (총 3번)
    - 1..1: 최대 5로 제한
    - 2..4: 최대 3개로 제한
    - 5..5: 최대 2개로 제한
4. 조회된 문제들을 합쳐서 리턴

#### 문제

1. **요구사항을 충족하지 못함!**
- 특정 범위에 문제수가 부족하고, 특정 범위는 문제수가 할당된 수 보다 많은 경우를 반영하지 못함.  
- 예를 들어
    - uc1510에 level이 1인 문제만 5개가 있다고 가정
    - 쿼리 파라미터: unitCode=[uc1510] / problemType=ALL / level=HIGH / totalCount=10   
      - 1..1 -> 2 / 2..4 -> 3 / 5..5 -> 5 할당 가능
    - level이 1인 문제만 5개 있기 때문에, 할당된 수(2) 상관 없이 5개 전부 조회되어야 함. 
    - 하지만 할당된 수 만큼 조회하기 때문에, level이 1인 문제를 2개밖에 조회하지 않고, 2개가 그대로 응답됨
2. 문제 수와 상관 없이, 쿼리가 무조건 3번 발생


### 해결방법 2

#### 순서
1. 난이도(숫자) 별로 그룹지어 unitCode, problemType에 따라 미리 가용 가능한 문제 수를 구함.
    - ex) { 1=5, 2=3, 3=1, 4=3, 5=2 }
2. 난이도를 범위(카테고리) 지어, 범위 별 가용 가능한 수를 구함
    - ex) { LOW=5, MIDDLE=7, HIGH=2 }
3. 총 가용 가능한 문제 수를 구해, totalCount와 비교하여, 도출해야 하는 남은 문제 수를 초기화
    - ex) totalCount = 10 vs LOW+MIDDLE+HIGH = 14 -> remainingCount = totalCount(10)
4. 요구사항에 따른 카테고리 별 비율을 구함
    - ex) HIGH -> { LOW=0.2, MIDDLE=0.3, HIGH=0.5 }
5. 카테고리 별 비율이 가장 높은 순으로 정렬하여 카테고리 우선순위를 구함
    - ex) { LOW=0.2, MIDDLE=0.3, HIGH=0.5 } -> priority = [HIGH, MIDDLE, LOW]
6. 카테고리 별 할당된 문제 수를 담는 Map을 만듬
7. 우선순위대로 반복하여 remainingCount가 0이 될 때까지 카테고리 별로 문제 수를 할당 함  
   1. 카테고리별 가용 가능한 문제 수(2번에서 구한 값)를 구함  
        - HIGH=2
   2. remainingCount가 0이거나, 가용 가능한 문제 수가 0인 경우 반복 즉시 종료
        - remainingCount가 = 10, 가용 가능한 문제 수 = 2 -> 종료하지 않음
   3. remainingCount와, 카테고리에 비율을 곱하여 할당 가능한 수를 구함
        - 10 * 0.5(HIGH) -> 5, 만약 1보다 작은 경우 1
   4. 할당 가능한 수와 가용 가능한 문제수 중 작은 값을 할당함
        - 6-1에서 구한 가용 가능한 문제 수 = 2 
        - 6-3에서 구한 할당 가능한 문제 수 = 5
        - 2까지 할당 가능
   5. 6에서 만든 Map에 할당된 수 추가
   6. 할당된 수 만큼 remainingCount 차감
   7. 할당된 수 만큼 가용 가능한 수 차감
   8. 6번 과정 반복
8. 최종적으로 카테고리 별 할당된 문제 수를 가지고 쿼리 (최소 0번, 최대 3번)
    - { LOW=3, MIDDLE=5, HIGH=2 } -> 1..1 은 3개까지, 2..4는 5개 까지, 5..5는 2개까지 

#### 고려사항
1. 난이도 별 속한 카테고리가 달라지거나, 카테고리 별로 속한 난이도 별 문제의 비율 달라질 경우에도 유연하게 대처 가능하도록 설계
    - 난이도 별 속한 카테고리가 달라지는 경우 -> ProblemLevelCategory만 변경하면 되게
    - 카테고리 별 속한 문제 비율이 달라지는 경우 -> QueryService에서 조회 로직만 변경하면 가능하게

2. Problem 도메인에 DB상 카테고리를 미리 도출해두는 방식은 어떤가?
    - 1번에 반하는 방식
    - 8번 과정에서 쿼리할 때만 효용성이 높아짐
    - 난이도(level)별 카테고리가 달라질 경우에, 전체 데이터 수정이 필요해짐
      - 예를 들어, LOW = 1..1 -> LOW = 1..2 로 바뀐다면, level이 2인 데이터는 category를 LOW로 모두 변경, 연관 인덱스까지 영향
    - 문제 수가 많으면 많을수록 비효율적인 방법이라 생각함

3. 쿼리 최적화 방향
    - 조건과 그룹핑에 활용되는 unit_code, level, problem_type를 풀 커버하는 커버링 인덱스 사용하여 쿼리 개선 방법이 더 좋다고 생각
    - 미리 unit_code, problem_type별 level에 해당하는 문제 수를 캐시해두는 전략도 고려

4. 문제 수가 부족하여 비율대로 떨어지지 않는 경우, 나머지 비율에 최적화 하여 맞추는 전략 고려
   ex) HIGH인 문제수가 50%가 안되는 경우, HIGH인 문제 수를 제외한 나머지 수에서 최대한 LOW 0.2, MIDDLE 0.3 비율이 반영될 수 있게끔 고려

### 다른 방법
카테고리 별로 문제를 최대 갯수만큼 미리 조회하는 방법

#### 순서
1. totalCount 만큼 1..1, 2..4, 5..5 모두 조회
   - ex) totalCount=100 -> 레벨이 1인 데이터 100개, 레벨이 2~4인 데이터 100개, 레벨이 5인 데이터 100개
2. 카테고리 별 비율 순서대로 문제를 변환함
   - level 파라미터가 HIGH인 경우
     - 100개 중 HIGH 비율(0.5) 까지 최대 변환(50개)
     - 남아있는 문제 수(100 - HIGH 변환 수) MIDDLE 문제 수를 MIDDLE 비율 까지 반영
     - 남아있는 문제 수 중 LOW문제 수를 LOW 비율 까지 반영

#### 장점: level을 그룹지어 쿼리를 날리지 않아도 됨
#### 단점: 인스턴스 사양, totalCount 에 따라 OOM 발생 가능성 염두

